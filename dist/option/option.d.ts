import { type Comparable, Ordering } from "../cmp/index.js";
import type { None, Option, Some } from "./types.js";
declare abstract class OptionBase<T> implements Comparable<Option<T>> {
    protected constructor();
    abstract isSome(): this is Some<T>;
    abstract isSomeAnd(predicate: (t: T) => boolean): boolean;
    abstract isNone(): this is None<T>;
    abstract isNoneOr(predicate: (t: T) => boolean): boolean;
    abstract peek(fn: (t: T) => void): this;
    abstract expect(msg: string): T;
    abstract unwrap(): T;
    abstract unwrapOr(fallback: T): T;
    abstract unwrapOrElse(fn: () => T): T;
    abstract map<U>(fn: (t: T) => U): Option<U>;
    abstract mapOr<U>(fallback: U, fn: (t: T) => U): U;
    abstract mapOrElse<U>(fallback: () => U, fn: (t: T) => U): U;
    abstract filter(predicate: (t: T) => boolean): Option<T>;
    abstract flatten<U, Inner extends Option<U>>(this: Option<Inner>): Inner;
    abstract zip<U>(other: Option<U>): Option<[T, U]>;
    abstract zipWith<U, R>(other: Option<U>, fn: (t: T, u: U) => R): Option<R>;
    abstract unzip<A, B>(this: Option<[A, B]>): [Option<A>, Option<B>];
    abstract and<U>(other: Option<U>): Option<U>;
    abstract andThen<U>(fn: (t: T) => Option<U>): Option<U>;
    abstract or(other: Option<T>): Option<T>;
    abstract orElse(fn: () => Option<T>): Option<T>;
    abstract xor(other: Option<T>): Option<T>;
    abstract iter(): Iterator<T>;
    abstract inserted<U>(u: U): Some<U>;
    insertedWith<U>(fn: () => U): Some<U>;
    abstract copy(): Option<T>;
    abstract clone(): Option<T>;
    abstract cmp(this: Option<T>, other: Option<T>): Ordering;
    eq<U>(this: Option<U>, other: Option<U>): boolean;
    ne(this: Option<T>, other: Option<T>): boolean;
    lt(this: Option<T>, other: Option<T>): boolean;
    le(this: Option<T>, other: Option<T>): boolean;
    gt(this: Option<T>, other: Option<T>): boolean;
    ge(this: Option<T>, other: Option<T>): boolean;
    min(this: Option<T>, other: Option<T>): Option<T>;
    max(this: Option<T>, other: Option<T>): Option<T>;
    clamp(this: Option<T>, min: Option<T>, max: Option<T>): Option<T>;
}
export { OptionBase };
