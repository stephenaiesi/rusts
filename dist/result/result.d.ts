import Ordering from "../cmp/Ordering.js";
import type { Comparable } from "../cmp/comparable.js";
import type { Err, Ok, Result } from "./types.js";
declare abstract class ResultBase<T, E> implements Comparable<Result<T, E>> {
    abstract kind: "ok" | "err";
    abstract readonly value: T | E;
    abstract isOk(): this is Ok<T, E>;
    abstract isOkAnd(predicate: (t: T) => boolean): boolean;
    abstract isErr(): this is Err<T, E>;
    abstract isErrAnd(predicate: (e: E) => boolean): boolean;
    abstract peek(fn: (t: T) => void): this;
    abstract peekErr(fn: (e: E) => void): this;
    abstract expect(msg: string): T;
    abstract unwrap(): T | never;
    abstract unwrapOr(fallback: T): T;
    abstract unwrapOrElse(fn: (e: E) => T): T;
    abstract expectErr(msg: string): E | never;
    abstract unwrapErr(): E | never;
    abstract map<U>(fn: (t: T) => U): Result<U, E>;
    abstract mapOr<U>(fallback: U, fn: (t: T) => U): U;
    abstract mapOrElse<U>(d: (e: E) => U, fn: (t: T) => U): U;
    abstract mapErr<F>(fn: (e: E) => F): Result<T, F>;
    abstract and<U>(other: Result<U, E>): Result<U, E>;
    abstract andThen<U>(fn: (t: T) => Result<U, E>): Result<U, E>;
    abstract or<F>(fallback: Result<T, F>): Result<T, F>;
    abstract orElse<F>(fn: (e: E) => Result<T, F>): Result<T, F>;
    abstract iter(): Iterator<T>;
    abstract copy(): Result<T, E>;
    abstract clone(): Result<T, E>;
    abstract cmp(this: Result<T, E>, other: Result<T, E>): Ordering;
    eq(this: Result<T, E>, other: Result<T, E>): boolean;
    ne(this: Result<T, E>, other: Result<T, E>): boolean;
    lt(this: Result<T, E>, other: Result<T, E>): boolean;
    le(this: Result<T, E>, other: Result<T, E>): boolean;
    gt(this: Result<T, E>, other: Result<T, E>): boolean;
    ge(this: Result<T, E>, other: Result<T, E>): boolean;
    max(this: Result<T, E>, other: Result<T, E>): Result<T, E>;
    min(this: Result<T, E>, other: Result<T, E>): Result<T, E>;
    clamp(this: Result<T, E>, min: Result<T, E>, max: Result<T, E>): Result<T, E>;
}
export { ResultBase };
